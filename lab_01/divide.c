#include "divide.h"

// Функция округления числа после достижения точности 41 до допустимых 40 
int rounding(my_float *result, int current_number)
{
    // Остановка функции в случае если 41-ая цифра меньше 5
    if (current_number < 5)
    {
        return 0;
    }
    int i = 39;
    // Цикл округления
    while (i >= 0)
    {
        // Увеличение первой цифры, не являющеся девяткой, на единицу и остановка округления
        if (result->mantissa[i] != '9')
        {
            result->mantissa[i] += 1;
            return 0;
        }
        // В случае если несколько последних цифр ялвяются двеятками - уменьшение длины мантиссы и переход к более ранней цифре
        else
        {
            result->mantissa[i--] = '\0';
            result->mantissa_len -= 1;
        }
    }
    // Резервная проверка случае числа 0.(9); в теории делением в данном варианте недостижима
    // Устанавливает мантиссу на 0.1, её длину на 1 и увеличивает экспоненту на 1
    if (i < 0)
    {
        result->mantissa[0] = '1';
        result->exponent += 1;
        result->mantissa_len += 1;
    }
    return 0;
}

// Функция нормализации числа (в данном случае используется для остатка от деления)
int normalize(char *number, int *number_len)
{
    int i = 0;
    // Подсчет нулей в начале числа
    while (number[i] == '0' && i < *number_len)
    {
        i++;
    }
    // Уменшьение длины числа на 1
    *number_len -= i;
    // Сдвиг числа с первой значимой цифры на кол-во незначащих нулей влево
    memmove(number, number + i, *number_len + 1);
    return i;
}

// Функция сравнения двух чисел лексографическим методом
// Вызываетя (всегда в данной программе) для остатка от деления (также являющегося частным от циклического вычитания) и мантиссы делителя
// Подразумевает, что при возврате 0 - числа равны, при положительном возвращаемом значении - первое число больше второго, и меньше при отрицательном соответственно
int compare(char *num_1, char *num_2, int len_1, int len_2) 
{
    // В сулчае неравенства длин возвращает разность первого и второго
    if (len_1 != len_2)
    {
        return len_1 - len_2;
    }
    // В случае равных длин проходится по каждому символу и возвращает разность первых несовпавших цифры первого и второго числа
    for (int i = 0; i < len_1; i++) 
    {
        if (num_1[i] != num_2[i]) 
        {
            return num_1[i] - num_2[i];
        }
    }
    // Возвращает 0 в случае идентичных чисел
    return 0;
}

// Функция вычитания первого числа из второго (алгоритм вычитания - в столбик)
// Предварительный вызов функции compare гарантирует что эта функция вызывается только при num_1 >= num_2
// Функция не возвращает результат вычитания а изменяет область памяти в которой записано число из которого происходит вычитание
void subtract(char *num_1, char *num_2, int len_1, int len_2)
{
    // Цикл с конца обоих чисел
    for (int i = len_1 - 1, j = len_2 - 1; j >= 0; i--, j--)
    {
        // В случае если последняя цифра первого числа больше последней цифры второго - вычитает из первой вторую и корректирует разность переменных типа char добавляя символ '0' для получения искомой цифры символом
        if (num_1[i] >= num_2[j])
        {
            num_1[i] = num_1[i] - num_2[j] + '0';
        }
        // Иначе - уменьшает предыдущую цифру первого числа, из текущей отнимает цифру второго числа, добавляет 10 и корректирующий символ '0'
        else
        {
            num_1[i] = '0' + 10 - num_2[j] + num_1[i];
            num_1[i - 1] -= 1;
        }
    }
}

// Основная функция деления
// Вызывается для мантисс двух чисел а не для самих чисел, т.е. для чисел 123 и 500, записанных как +0.123E+3 и +0.5E+3 происходит деление 123/5
// При таком делении необходима корректировка экспоненты, которая объясняется позже 
int divide(my_float *divident, my_float *divisor, my_float *result)
{
    // Проверка деления на ноль и деления нуля (обязательно в этом порядке для случая 0/0)
    if (divisor->mantissa[0] == '0')
    {
        return DIVISION_BY_ZERO;
    }
    if (divident->mantissa[0] == '0')
    {
        memcpy(result, divident, sizeof(my_float));
        return OK;
    }

    // Установка знака результата '+' в случаае равных знаком делимого и делителя, иначе - знака '-'
    result->mantissa_len = 0;
    result->sign = (divident->sign == divisor->sign ? '+' : '-');

    // Установка текущего остатка от деления на первый символ мантиссы делимого, длины остатка и указателя на мантиссу делимого
    char remainder[42] = { 0 };
    remainder[0] = divident->mantissa[0];
    int remainder_len = 1;
    int pointer = 1;

    int checkzero = 0;
    int pos_exp_correction = 0, neg_exp_correction = 0;
    char flag_neg = 0, flag_pos = 0;
    // Цикл до длины мантиссы равной 41 (фактически остановится раньше, в самом длинном случае - на длине 40 и округлится функцией rounding)
    while (result->mantissa_len < 41)
    {
        int cmp;
        // Сравнение текущего остатка и делителя
        cmp = compare(remainder, divisor->mantissa, remainder_len, divisor->mantissa_len);
        if (cmp < 0)
        {
            // В случае если текущий остаток меньше мантиссы делителя (далее - просто "делителя") сносит следущую цифру из делимого, либо добавляет 0 в случае если мантисса делимого закончиась
            if (pointer < divident->mantissa_len)
            {
                remainder[remainder_len++] = divident->mantissa[pointer++];
            }
            else
            {
                remainder[remainder_len++] = '0';
                // Добавляет "негативную" корректировку экспоненты если позволяет флаг
                if (!flag_neg)
                {
                    neg_exp_correction++;
                }
                // В классическом алгоритме после числа ставится точка, следовательно для примера 123/5 = 24.6 "положительный" сдвиг экспоненты будет равен 2, а шага деления в столбик будет 3
                // Потому после сноса первого нуля не из делимого (т.к. в данном алгоритме положительная экспонента растет в другой части кода и без флага способна расти и после снова первого нуля) необходимо запретить дальнейши рост установкой флага
                flag_pos = 1;
            }
            // В случае если после сноса очередного числа деление невозможно, по алгоритму деления в столбик сноситя еще одно число, а в результат записывается '0'
            // Но для нормализации экспоненты (прим. : 1/999 = 0.001001... == 0.1001001...E-2) число в результат записывается в случае если естановлен флаг checkzero
            // Флаг checkzero в дальнейшей устанавливается после записи первой ненулевой цифры в результат
            if (checkzero && compare(remainder, divisor->mantissa, remainder_len, divisor->mantissa_len) < 0)
            {
                if (result->mantissa_len == 40)
                {
                    break;
                }
                result->mantissa[result->mantissa_len++] = '0';
            }
        }
        else
        {
            // В случае если текущий остаток больше делителя
            int cur_number = 0;
            // Запускается циклический алгоритм вычитания делителя из остатка
            // Каждая итерация добавляет к текущей цифре 1, также после каждого вычитания остаток нормализуется ('12' - '5' = '07', len = 2 -> '7', len = 1)
            // Цикл продолжается пока остаток больше делителя
            while (cmp >= 0)
            {
                subtract(remainder, divisor->mantissa, remainder_len, divisor->mantissa_len);
                normalize(remainder, &remainder_len);
                cur_number++;
                cmp = compare(remainder, divisor->mantissa, remainder_len, divisor->mantissa_len);
            }
            // В сллучае если длина мантиссы достигла 40 - вызвает функцию округления найденного 41-ого числа и останавливает весь цикл 
            if (result->mantissa_len == 40)
            {
                rounding(result, cur_number);
                break;
            }
            // Иначе - записывает очередное число на необходимую позицию и увеличивает длину мантиссы результата на 1
            result->mantissa[result->mantissa_len++] = '0' + cur_number;
            result->mantissa[result->mantissa_len] = '\0';
            // "Позитивная" корректировка экспоненты растет при записи очередного числа в результат
            // Как указано ранее - флаг останавливает рост положительной корректировки после сноса первого нуля
            if (!flag_pos)
            {
                pos_exp_correction++;
            }
            // Как было указано ранее в одном из примеров, 1/999 = 0.001001... = 0.1001001...E-2
            // В данном случае после окончания делителя из пустоты сносится еще три дополнительных нуля, но нормальная форма получается после сноса первого, и настоящий рост начинается после сноса второго
            // Тем не менее, рост "негативной" корректировки идет после сноса каждого, и останавливается после первого ненулевого числа; данный нюанс учитывается позже
            flag_neg = 1;
            // Флаг checkzero предотвращает пропуск нулей после первого (только что записанного) ненулевого записанного значения
            checkzero = 1;
            if (remainder_len == 0 && pointer == divident->mantissa_len)
            {
                break;
            }
            // Флаги checkzero и flag_neg несут в себе идентичную информацию, но разный смысл, поэтому имеет место создание двух переменных, хоть достаточно только одной из них
        }
    }
    // Экспонента итогового числа, как следует из математики, равна разности эскпонент делимого и делителя
    // Первая корректировка заключается в том, что, как указано ранее, 0.123E+3/0.5E+3 превращается в 123/5
    // Из-за этого, для корректировки результата, он умножается на длину делителя и делится на длину делимого
    // Для экспоненты это означает вычитание из нее разности длин делимого и делителя
    // После чего, в случае наличия позитивной корректировки она добавляется к итоговой (т.е 123/5 = 24.6 = 0.246 * E+2, данное +2 суммируется с итоговой экспонентой, зависящей от других факторов)
    // В случае негативной корректировки, т.е если первое значащее число идет после точки при делении, от итоговой экспоненты вычитается негативная корректировка уменьшенная на единицу
    result->exponent = (divident->exponent - divisor->exponent) - (divident->mantissa_len - divisor->mantissa_len);
    if (pos_exp_correction)
    {
        result->exponent += pos_exp_correction;
    }
    else
    {
        result->exponent -= (neg_exp_correction - 1);
    }
    // Возврат кода исключительного случая если иттоговая экспонента результата выходит за пределы допустимых значений
    if (result->exponent < -99999 || result->exponent > 99999)
    {
        return RESULT_ORDER_OUT_OF_RANGE;
    }
    return OK;
}
